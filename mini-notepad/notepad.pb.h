// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notepad.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_notepad_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
    class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_notepad_2eproto
{
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_notepad_2eproto;
namespace notepad
{
    class Change;
    struct ChangeDefaultTypeInternal;
    extern ChangeDefaultTypeInternal _Change_default_instance_;
    class Content;
    struct ContentDefaultTypeInternal;
    extern ContentDefaultTypeInternal _Content_default_instance_;
    class Notepad;
    struct NotepadDefaultTypeInternal;
    extern NotepadDefaultTypeInternal _Notepad_default_instance_;
    class User;
    struct UserDefaultTypeInternal;
    extern UserDefaultTypeInternal _User_default_instance_;
    class Users;
    struct UsersDefaultTypeInternal;
    extern UsersDefaultTypeInternal _Users_default_instance_;
    class Version;
    struct VersionDefaultTypeInternal;
    extern VersionDefaultTypeInternal _Version_default_instance_;
    class Versions;
    struct VersionsDefaultTypeInternal;
    extern VersionsDefaultTypeInternal _Versions_default_instance_;
} // namespace notepad
PROTOBUF_NAMESPACE_OPEN
template <>
::notepad::Change *Arena::CreateMaybeMessage<::notepad::Change>(Arena *);
template <>
::notepad::Content *Arena::CreateMaybeMessage<::notepad::Content>(Arena *);
template <>
::notepad::Notepad *Arena::CreateMaybeMessage<::notepad::Notepad>(Arena *);
template <>
::notepad::User *Arena::CreateMaybeMessage<::notepad::User>(Arena *);
template <>
::notepad::Users *Arena::CreateMaybeMessage<::notepad::Users>(Arena *);
template <>
::notepad::Version *Arena::CreateMaybeMessage<::notepad::Version>(Arena *);
template <>
::notepad::Versions *Arena::CreateMaybeMessage<::notepad::Versions>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace notepad
{

    enum ChangeName : int
    {
        ADD = 0,
        REMOVE = 1,
        UPDATE = 2,
        ChangeName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ChangeName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ChangeName_IsValid(int value);
    constexpr ChangeName ChangeName_MIN = ADD;
    constexpr ChangeName ChangeName_MAX = UPDATE;
    constexpr int ChangeName_ARRAYSIZE = ChangeName_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *ChangeName_descriptor();
    template <typename T>
    inline const std::string &ChangeName_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ChangeName>::value ||
                          ::std::is_integral<T>::value,
                      "Incorrect type passed to function ChangeName_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ChangeName_descriptor(), enum_t_value);
    }
    inline bool ChangeName_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeName *value)
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeName>(
            ChangeName_descriptor(), name, value);
    }
    // ===================================================================

    class User final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.User) */
    {
    public:
        inline User() : User(nullptr) {}
        ~User() override;
        explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        User(const User &from);
        User(User &&from) noexcept
            : User()
        {
            *this = ::std::move(from);
        }

        inline User &operator=(const User &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline User &operator=(User &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const User &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const User *internal_default_instance()
        {
            return reinterpret_cast<const User *>(
                &_User_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            0;

        friend void swap(User &a, User &b)
        {
            a.Swap(&b);
        }
        inline void Swap(User *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(User *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        User *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<User>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const User &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const User &from)
        {
            User::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(User *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.User";
        }

    protected:
        explicit User(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                      bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kNameFieldNumber = 1,
            kEmailFieldNumber = 2,
            kPasswordFieldNumber = 3,
            kLocationFieldNumber = 4,
        };
        // string name = 1;
        void clear_name();
        const std::string &name() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_name(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_name();
        PROTOBUF_NODISCARD std::string *release_name();
        void set_allocated_name(std::string *name);

    private:
        const std::string &_internal_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string &value);
        std::string *_internal_mutable_name();

    public:
        // string email = 2;
        void clear_email();
        const std::string &email() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_email(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_email();
        PROTOBUF_NODISCARD std::string *release_email();
        void set_allocated_email(std::string *email);

    private:
        const std::string &_internal_email() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string &value);
        std::string *_internal_mutable_email();

    public:
        // string password = 3;
        void clear_password();
        const std::string &password() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_password(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_password();
        PROTOBUF_NODISCARD std::string *release_password();
        void set_allocated_password(std::string *password);

    private:
        const std::string &_internal_password() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string &value);
        std::string *_internal_mutable_password();

    public:
        // string location = 4;
        void clear_location();
        const std::string &location() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_location(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_location();
        PROTOBUF_NODISCARD std::string *release_location();
        void set_allocated_location(std::string *location);

    private:
        const std::string &_internal_location() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string &value);
        std::string *_internal_mutable_location();

    public:
        // @@protoc_insertion_point(class_scope:notepad.User)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Users final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Users) */
    {
    public:
        inline Users() : Users(nullptr) {}
        ~Users() override;
        explicit PROTOBUF_CONSTEXPR Users(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Users(const Users &from);
        Users(Users &&from) noexcept
            : Users()
        {
            *this = ::std::move(from);
        }

        inline Users &operator=(const Users &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Users &operator=(Users &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Users &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Users *internal_default_instance()
        {
            return reinterpret_cast<const Users *>(
                &_Users_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            1;

        friend void swap(Users &a, Users &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Users *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Users *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Users *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Users>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Users &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Users &from)
        {
            Users::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Users *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Users";
        }

    protected:
        explicit Users(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                       bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kUsersFieldNumber = 1,
        };
        // repeated .notepad.User users = 1;
        int users_size() const;

    private:
        int _internal_users_size() const;

    public:
        void clear_users();
        ::notepad::User *mutable_users(int index);
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> *
        mutable_users();

    private:
        const ::notepad::User &_internal_users(int index) const;
        ::notepad::User *_internal_add_users();

    public:
        const ::notepad::User &users(int index) const;
        ::notepad::User *add_users();
        const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> &
        users() const;

        // @@protoc_insertion_point(class_scope:notepad.Users)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> users_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Content final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Content) */
    {
    public:
        inline Content() : Content(nullptr) {}
        ~Content() override;
        explicit PROTOBUF_CONSTEXPR Content(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Content(const Content &from);
        Content(Content &&from) noexcept
            : Content()
        {
            *this = ::std::move(from);
        }

        inline Content &operator=(const Content &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Content &operator=(Content &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Content &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Content *internal_default_instance()
        {
            return reinterpret_cast<const Content *>(
                &_Content_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            2;

        friend void swap(Content &a, Content &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Content *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Content *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Content *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Content>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Content &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Content &from)
        {
            Content::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Content *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Content";
        }

    protected:
        explicit Content(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                         bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kLineFieldNumber = 1,
        };
        // string line = 1;
        void clear_line();
        const std::string &line() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_line(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_line();
        PROTOBUF_NODISCARD std::string *release_line();
        void set_allocated_line(std::string *line);

    private:
        const std::string &_internal_line() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_line(const std::string &value);
        std::string *_internal_mutable_line();

    public:
        // @@protoc_insertion_point(class_scope:notepad.Content)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Notepad final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Notepad) */
    {
    public:
        inline Notepad() : Notepad(nullptr) {}
        ~Notepad() override;
        explicit PROTOBUF_CONSTEXPR Notepad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Notepad(const Notepad &from);
        Notepad(Notepad &&from) noexcept
            : Notepad()
        {
            *this = ::std::move(from);
        }

        inline Notepad &operator=(const Notepad &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Notepad &operator=(Notepad &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Notepad &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Notepad *internal_default_instance()
        {
            return reinterpret_cast<const Notepad *>(
                &_Notepad_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            3;

        friend void swap(Notepad &a, Notepad &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Notepad *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Notepad *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Notepad *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Notepad>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Notepad &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Notepad &from)
        {
            Notepad::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Notepad *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Notepad";
        }

    protected:
        explicit Notepad(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                         bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kContentsFieldNumber = 4,
            kIdFieldNumber = 1,
            kNameFieldNumber = 2,
            kUserNameFieldNumber = 3,
        };
        // repeated .notepad.Content contents = 4;
        int contents_size() const;

    private:
        int _internal_contents_size() const;

    public:
        void clear_contents();
        ::notepad::Content *mutable_contents(int index);
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> *
        mutable_contents();

    private:
        const ::notepad::Content &_internal_contents(int index) const;
        ::notepad::Content *_internal_add_contents();

    public:
        const ::notepad::Content &contents(int index) const;
        ::notepad::Content *add_contents();
        const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> &
        contents() const;

        // string id = 1;
        void clear_id();
        const std::string &id() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_id(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_id();
        PROTOBUF_NODISCARD std::string *release_id();
        void set_allocated_id(std::string *id);

    private:
        const std::string &_internal_id() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string &value);
        std::string *_internal_mutable_id();

    public:
        // string name = 2;
        void clear_name();
        const std::string &name() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_name(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_name();
        PROTOBUF_NODISCARD std::string *release_name();
        void set_allocated_name(std::string *name);

    private:
        const std::string &_internal_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string &value);
        std::string *_internal_mutable_name();

    public:
        // string user_name = 3;
        void clear_user_name();
        const std::string &user_name() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_user_name(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_user_name();
        PROTOBUF_NODISCARD std::string *release_user_name();
        void set_allocated_user_name(std::string *user_name);

    private:
        const std::string &_internal_user_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string &value);
        std::string *_internal_mutable_user_name();

    public:
        // @@protoc_insertion_point(class_scope:notepad.Notepad)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> contents_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Change final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Change) */
    {
    public:
        inline Change() : Change(nullptr) {}
        ~Change() override;
        explicit PROTOBUF_CONSTEXPR Change(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Change(const Change &from);
        Change(Change &&from) noexcept
            : Change()
        {
            *this = ::std::move(from);
        }

        inline Change &operator=(const Change &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Change &operator=(Change &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Change &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Change *internal_default_instance()
        {
            return reinterpret_cast<const Change *>(
                &_Change_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            4;

        friend void swap(Change &a, Change &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Change *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Change *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Change *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Change>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Change &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Change &from)
        {
            Change::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Change *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Change";
        }

    protected:
        explicit Change(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                        bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kContentsFieldNumber = 4,
            kNameFieldNumber = 1,
            kStartLineFieldNumber = 2,
            kEndLineFieldNumber = 3,
        };
        // repeated .notepad.Content contents = 4;
        int contents_size() const;

    private:
        int _internal_contents_size() const;

    public:
        void clear_contents();
        ::notepad::Content *mutable_contents(int index);
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> *
        mutable_contents();

    private:
        const ::notepad::Content &_internal_contents(int index) const;
        ::notepad::Content *_internal_add_contents();

    public:
        const ::notepad::Content &contents(int index) const;
        ::notepad::Content *add_contents();
        const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> &
        contents() const;

        // .notepad.ChangeName name = 1;
        void clear_name();
        ::notepad::ChangeName name() const;
        void set_name(::notepad::ChangeName value);

    private:
        ::notepad::ChangeName _internal_name() const;
        void _internal_set_name(::notepad::ChangeName value);

    public:
        // int32 start_line = 2;
        void clear_start_line();
        int32_t start_line() const;
        void set_start_line(int32_t value);

    private:
        int32_t _internal_start_line() const;
        void _internal_set_start_line(int32_t value);

    public:
        // int32 end_line = 3;
        void clear_end_line();
        int32_t end_line() const;
        void set_end_line(int32_t value);

    private:
        int32_t _internal_end_line() const;
        void _internal_set_end_line(int32_t value);

    public:
        // @@protoc_insertion_point(class_scope:notepad.Change)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> contents_;
            int name_;
            int32_t start_line_;
            int32_t end_line_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Version final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Version) */
    {
    public:
        inline Version() : Version(nullptr) {}
        ~Version() override;
        explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Version(const Version &from);
        Version(Version &&from) noexcept
            : Version()
        {
            *this = ::std::move(from);
        }

        inline Version &operator=(const Version &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Version &operator=(Version &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Version &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Version *internal_default_instance()
        {
            return reinterpret_cast<const Version *>(
                &_Version_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            5;

        friend void swap(Version &a, Version &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Version *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Version *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Version *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Version>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Version &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Version &from)
        {
            Version::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Version *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Version";
        }

    protected:
        explicit Version(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                         bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kChangesFieldNumber = 5,
            kIdFieldNumber = 1,
            kCreatedTimeFieldNumber = 3,
            kNotepadIdFieldNumber = 4,
            kNumberFieldNumber = 2,
        };
        // repeated .notepad.Change changes = 5;
        int changes_size() const;

    private:
        int _internal_changes_size() const;

    public:
        void clear_changes();
        ::notepad::Change *mutable_changes(int index);
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Change> *
        mutable_changes();

    private:
        const ::notepad::Change &_internal_changes(int index) const;
        ::notepad::Change *_internal_add_changes();

    public:
        const ::notepad::Change &changes(int index) const;
        ::notepad::Change *add_changes();
        const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Change> &
        changes() const;

        // string id = 1;
        void clear_id();
        const std::string &id() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_id(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_id();
        PROTOBUF_NODISCARD std::string *release_id();
        void set_allocated_id(std::string *id);

    private:
        const std::string &_internal_id() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string &value);
        std::string *_internal_mutable_id();

    public:
        // string created_time = 3;
        void clear_created_time();
        const std::string &created_time() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_created_time(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_created_time();
        PROTOBUF_NODISCARD std::string *release_created_time();
        void set_allocated_created_time(std::string *created_time);

    private:
        const std::string &_internal_created_time() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_time(const std::string &value);
        std::string *_internal_mutable_created_time();

    public:
        // string notepad_id = 4;
        void clear_notepad_id();
        const std::string &notepad_id() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_notepad_id(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_notepad_id();
        PROTOBUF_NODISCARD std::string *release_notepad_id();
        void set_allocated_notepad_id(std::string *notepad_id);

    private:
        const std::string &_internal_notepad_id() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_notepad_id(const std::string &value);
        std::string *_internal_mutable_notepad_id();

    public:
        // int32 number = 2;
        void clear_number();
        int32_t number() const;
        void set_number(int32_t value);

    private:
        int32_t _internal_number() const;
        void _internal_set_number(int32_t value);

    public:
        // @@protoc_insertion_point(class_scope:notepad.Version)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Change> changes_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_time_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notepad_id_;
            int32_t number_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Versions final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Versions) */
    {
    public:
        inline Versions() : Versions(nullptr) {}
        ~Versions() override;
        explicit PROTOBUF_CONSTEXPR Versions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Versions(const Versions &from);
        Versions(Versions &&from) noexcept
            : Versions()
        {
            *this = ::std::move(from);
        }

        inline Versions &operator=(const Versions &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Versions &operator=(Versions &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Versions &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Versions *internal_default_instance()
        {
            return reinterpret_cast<const Versions *>(
                &_Versions_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            6;

        friend void swap(Versions &a, Versions &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Versions *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Versions *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Versions *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Versions>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Versions &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Versions &from)
        {
            Versions::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Versions *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Versions";
        }

    protected:
        explicit Versions(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                          bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kVersionsFieldNumber = 1,
        };
        // repeated .notepad.Version versions = 1;
        int versions_size() const;

    private:
        int _internal_versions_size() const;

    public:
        void clear_versions();
        ::notepad::Version *mutable_versions(int index);
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Version> *
        mutable_versions();

    private:
        const ::notepad::Version &_internal_versions(int index) const;
        ::notepad::Version *_internal_add_versions();

    public:
        const ::notepad::Version &versions(int index) const;
        ::notepad::Version *add_versions();
        const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Version> &
        versions() const;

        // @@protoc_insertion_point(class_scope:notepad.Versions)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Version> versions_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // ===================================================================

    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
    // User

    // string name = 1;
    inline void User::clear_name()
    {
        _impl_.name_.ClearToEmpty();
    }
    inline const std::string &User::name() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.name)
        return _internal_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_name(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.name)
    }
    inline std::string *User::mutable_name()
    {
        std::string *_s = _internal_mutable_name();
        // @@protoc_insertion_point(field_mutable:notepad.User.name)
        return _s;
    }
    inline const std::string &User::_internal_name() const
    {
        return _impl_.name_.Get();
    }
    inline void User::_internal_set_name(const std::string &value)
    {

        _impl_.name_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_name()
    {

        return _impl_.name_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_name()
    {
        // @@protoc_insertion_point(field_release:notepad.User.name)
        return _impl_.name_.Release();
    }
    inline void User::set_allocated_name(std::string *name)
    {
        if (name != nullptr)
        {
        }
        else
        {
        }
        _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault())
        {
            _impl_.name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.name)
    }

    // string email = 2;
    inline void User::clear_email()
    {
        _impl_.email_.ClearToEmpty();
    }
    inline const std::string &User::email() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.email)
        return _internal_email();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_email(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.email)
    }
    inline std::string *User::mutable_email()
    {
        std::string *_s = _internal_mutable_email();
        // @@protoc_insertion_point(field_mutable:notepad.User.email)
        return _s;
    }
    inline const std::string &User::_internal_email() const
    {
        return _impl_.email_.Get();
    }
    inline void User::_internal_set_email(const std::string &value)
    {

        _impl_.email_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_email()
    {

        return _impl_.email_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_email()
    {
        // @@protoc_insertion_point(field_release:notepad.User.email)
        return _impl_.email_.Release();
    }
    inline void User::set_allocated_email(std::string *email)
    {
        if (email != nullptr)
        {
        }
        else
        {
        }
        _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault())
        {
            _impl_.email_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.email)
    }

    // string password = 3;
    inline void User::clear_password()
    {
        _impl_.password_.ClearToEmpty();
    }
    inline const std::string &User::password() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.password)
        return _internal_password();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_password(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.password)
    }
    inline std::string *User::mutable_password()
    {
        std::string *_s = _internal_mutable_password();
        // @@protoc_insertion_point(field_mutable:notepad.User.password)
        return _s;
    }
    inline const std::string &User::_internal_password() const
    {
        return _impl_.password_.Get();
    }
    inline void User::_internal_set_password(const std::string &value)
    {

        _impl_.password_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_password()
    {

        return _impl_.password_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_password()
    {
        // @@protoc_insertion_point(field_release:notepad.User.password)
        return _impl_.password_.Release();
    }
    inline void User::set_allocated_password(std::string *password)
    {
        if (password != nullptr)
        {
        }
        else
        {
        }
        _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault())
        {
            _impl_.password_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.password)
    }

    // string location = 4;
    inline void User::clear_location()
    {
        _impl_.location_.ClearToEmpty();
    }
    inline const std::string &User::location() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.location)
        return _internal_location();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_location(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.location)
    }
    inline std::string *User::mutable_location()
    {
        std::string *_s = _internal_mutable_location();
        // @@protoc_insertion_point(field_mutable:notepad.User.location)
        return _s;
    }
    inline const std::string &User::_internal_location() const
    {
        return _impl_.location_.Get();
    }
    inline void User::_internal_set_location(const std::string &value)
    {

        _impl_.location_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_location()
    {

        return _impl_.location_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_location()
    {
        // @@protoc_insertion_point(field_release:notepad.User.location)
        return _impl_.location_.Release();
    }
    inline void User::set_allocated_location(std::string *location)
    {
        if (location != nullptr)
        {
        }
        else
        {
        }
        _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault())
        {
            _impl_.location_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.location)
    }

    // -------------------------------------------------------------------

    // Users

    // repeated .notepad.User users = 1;
    inline int Users::_internal_users_size() const
    {
        return _impl_.users_.size();
    }
    inline int Users::users_size() const
    {
        return _internal_users_size();
    }
    inline void Users::clear_users()
    {
        _impl_.users_.Clear();
    }
    inline ::notepad::User *Users::mutable_users(int index)
    {
        // @@protoc_insertion_point(field_mutable:notepad.Users.users)
        return _impl_.users_.Mutable(index);
    }
    inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> *
    Users::mutable_users()
    {
        // @@protoc_insertion_point(field_mutable_list:notepad.Users.users)
        return &_impl_.users_;
    }
    inline const ::notepad::User &Users::_internal_users(int index) const
    {
        return _impl_.users_.Get(index);
    }
    inline const ::notepad::User &Users::users(int index) const
    {
        // @@protoc_insertion_point(field_get:notepad.Users.users)
        return _internal_users(index);
    }
    inline ::notepad::User *Users::_internal_add_users()
    {
        return _impl_.users_.Add();
    }
    inline ::notepad::User *Users::add_users()
    {
        ::notepad::User *_add = _internal_add_users();
        // @@protoc_insertion_point(field_add:notepad.Users.users)
        return _add;
    }
    inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> &
    Users::users() const
    {
        // @@protoc_insertion_point(field_list:notepad.Users.users)
        return _impl_.users_;
    }

    // -------------------------------------------------------------------

    // Content

    // string line = 1;
    inline void Content::clear_line()
    {
        _impl_.line_.ClearToEmpty();
    }
    inline const std::string &Content::line() const
    {
        // @@protoc_insertion_point(field_get:notepad.Content.line)
        return _internal_line();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Content::set_line(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.line_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Content.line)
    }
    inline std::string *Content::mutable_line()
    {
        std::string *_s = _internal_mutable_line();
        // @@protoc_insertion_point(field_mutable:notepad.Content.line)
        return _s;
    }
    inline const std::string &Content::_internal_line() const
    {
        return _impl_.line_.Get();
    }
    inline void Content::_internal_set_line(const std::string &value)
    {

        _impl_.line_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Content::_internal_mutable_line()
    {

        return _impl_.line_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Content::release_line()
    {
        // @@protoc_insertion_point(field_release:notepad.Content.line)
        return _impl_.line_.Release();
    }
    inline void Content::set_allocated_line(std::string *line)
    {
        if (line != nullptr)
        {
        }
        else
        {
        }
        _impl_.line_.SetAllocated(line, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.line_.IsDefault())
        {
            _impl_.line_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Content.line)
    }

    // -------------------------------------------------------------------

    // Notepad

    // string id = 1;
    inline void Notepad::clear_id()
    {
        _impl_.id_.ClearToEmpty();
    }
    inline const std::string &Notepad::id() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.id)
        return _internal_id();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_id(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.id)
    }
    inline std::string *Notepad::mutable_id()
    {
        std::string *_s = _internal_mutable_id();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.id)
        return _s;
    }
    inline const std::string &Notepad::_internal_id() const
    {
        return _impl_.id_.Get();
    }
    inline void Notepad::_internal_set_id(const std::string &value)
    {

        _impl_.id_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_id()
    {

        return _impl_.id_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_id()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.id)
        return _impl_.id_.Release();
    }
    inline void Notepad::set_allocated_id(std::string *id)
    {
        if (id != nullptr)
        {
        }
        else
        {
        }
        _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault())
        {
            _impl_.id_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.id)
    }

    // string name = 2;
    inline void Notepad::clear_name()
    {
        _impl_.name_.ClearToEmpty();
    }
    inline const std::string &Notepad::name() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.name)
        return _internal_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_name(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.name)
    }
    inline std::string *Notepad::mutable_name()
    {
        std::string *_s = _internal_mutable_name();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.name)
        return _s;
    }
    inline const std::string &Notepad::_internal_name() const
    {
        return _impl_.name_.Get();
    }
    inline void Notepad::_internal_set_name(const std::string &value)
    {

        _impl_.name_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_name()
    {

        return _impl_.name_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_name()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.name)
        return _impl_.name_.Release();
    }
    inline void Notepad::set_allocated_name(std::string *name)
    {
        if (name != nullptr)
        {
        }
        else
        {
        }
        _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault())
        {
            _impl_.name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.name)
    }

    // string user_name = 3;
    inline void Notepad::clear_user_name()
    {
        _impl_.user_name_.ClearToEmpty();
    }
    inline const std::string &Notepad::user_name() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.user_name)
        return _internal_user_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_user_name(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.user_name)
    }
    inline std::string *Notepad::mutable_user_name()
    {
        std::string *_s = _internal_mutable_user_name();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.user_name)
        return _s;
    }
    inline const std::string &Notepad::_internal_user_name() const
    {
        return _impl_.user_name_.Get();
    }
    inline void Notepad::_internal_set_user_name(const std::string &value)
    {

        _impl_.user_name_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_user_name()
    {

        return _impl_.user_name_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_user_name()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.user_name)
        return _impl_.user_name_.Release();
    }
    inline void Notepad::set_allocated_user_name(std::string *user_name)
    {
        if (user_name != nullptr)
        {
        }
        else
        {
        }
        _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_name_.IsDefault())
        {
            _impl_.user_name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.user_name)
    }

    // repeated .notepad.Content contents = 4;
    inline int Notepad::_internal_contents_size() const
    {
        return _impl_.contents_.size();
    }
    inline int Notepad::contents_size() const
    {
        return _internal_contents_size();
    }
    inline void Notepad::clear_contents()
    {
        _impl_.contents_.Clear();
    }
    inline ::notepad::Content *Notepad::mutable_contents(int index)
    {
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.contents)
        return _impl_.contents_.Mutable(index);
    }
    inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> *
    Notepad::mutable_contents()
    {
        // @@protoc_insertion_point(field_mutable_list:notepad.Notepad.contents)
        return &_impl_.contents_;
    }
    inline const ::notepad::Content &Notepad::_internal_contents(int index) const
    {
        return _impl_.contents_.Get(index);
    }
    inline const ::notepad::Content &Notepad::contents(int index) const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.contents)
        return _internal_contents(index);
    }
    inline ::notepad::Content *Notepad::_internal_add_contents()
    {
        return _impl_.contents_.Add();
    }
    inline ::notepad::Content *Notepad::add_contents()
    {
        ::notepad::Content *_add = _internal_add_contents();
        // @@protoc_insertion_point(field_add:notepad.Notepad.contents)
        return _add;
    }
    inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> &
    Notepad::contents() const
    {
        // @@protoc_insertion_point(field_list:notepad.Notepad.contents)
        return _impl_.contents_;
    }

    // -------------------------------------------------------------------

    // Change

    // .notepad.ChangeName name = 1;
    inline void Change::clear_name()
    {
        _impl_.name_ = 0;
    }
    inline ::notepad::ChangeName Change::_internal_name() const
    {
        return static_cast<::notepad::ChangeName>(_impl_.name_);
    }
    inline ::notepad::ChangeName Change::name() const
    {
        // @@protoc_insertion_point(field_get:notepad.Change.name)
        return _internal_name();
    }
    inline void Change::_internal_set_name(::notepad::ChangeName value)
    {

        _impl_.name_ = value;
    }
    inline void Change::set_name(::notepad::ChangeName value)
    {
        _internal_set_name(value);
        // @@protoc_insertion_point(field_set:notepad.Change.name)
    }

    // int32 start_line = 2;
    inline void Change::clear_start_line()
    {
        _impl_.start_line_ = 0;
    }
    inline int32_t Change::_internal_start_line() const
    {
        return _impl_.start_line_;
    }
    inline int32_t Change::start_line() const
    {
        // @@protoc_insertion_point(field_get:notepad.Change.start_line)
        return _internal_start_line();
    }
    inline void Change::_internal_set_start_line(int32_t value)
    {

        _impl_.start_line_ = value;
    }
    inline void Change::set_start_line(int32_t value)
    {
        _internal_set_start_line(value);
        // @@protoc_insertion_point(field_set:notepad.Change.start_line)
    }

    // int32 end_line = 3;
    inline void Change::clear_end_line()
    {
        _impl_.end_line_ = 0;
    }
    inline int32_t Change::_internal_end_line() const
    {
        return _impl_.end_line_;
    }
    inline int32_t Change::end_line() const
    {
        // @@protoc_insertion_point(field_get:notepad.Change.end_line)
        return _internal_end_line();
    }
    inline void Change::_internal_set_end_line(int32_t value)
    {

        _impl_.end_line_ = value;
    }
    inline void Change::set_end_line(int32_t value)
    {
        _internal_set_end_line(value);
        // @@protoc_insertion_point(field_set:notepad.Change.end_line)
    }

    // repeated .notepad.Content contents = 4;
    inline int Change::_internal_contents_size() const
    {
        return _impl_.contents_.size();
    }
    inline int Change::contents_size() const
    {
        return _internal_contents_size();
    }
    inline void Change::clear_contents()
    {
        _impl_.contents_.Clear();
    }
    inline ::notepad::Content *Change::mutable_contents(int index)
    {
        // @@protoc_insertion_point(field_mutable:notepad.Change.contents)
        return _impl_.contents_.Mutable(index);
    }
    inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> *
    Change::mutable_contents()
    {
        // @@protoc_insertion_point(field_mutable_list:notepad.Change.contents)
        return &_impl_.contents_;
    }
    inline const ::notepad::Content &Change::_internal_contents(int index) const
    {
        return _impl_.contents_.Get(index);
    }
    inline const ::notepad::Content &Change::contents(int index) const
    {
        // @@protoc_insertion_point(field_get:notepad.Change.contents)
        return _internal_contents(index);
    }
    inline ::notepad::Content *Change::_internal_add_contents()
    {
        return _impl_.contents_.Add();
    }
    inline ::notepad::Content *Change::add_contents()
    {
        ::notepad::Content *_add = _internal_add_contents();
        // @@protoc_insertion_point(field_add:notepad.Change.contents)
        return _add;
    }
    inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Content> &
    Change::contents() const
    {
        // @@protoc_insertion_point(field_list:notepad.Change.contents)
        return _impl_.contents_;
    }

    // -------------------------------------------------------------------

    // Version

    // string id = 1;
    inline void Version::clear_id()
    {
        _impl_.id_.ClearToEmpty();
    }
    inline const std::string &Version::id() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.id)
        return _internal_id();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_id(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.id)
    }
    inline std::string *Version::mutable_id()
    {
        std::string *_s = _internal_mutable_id();
        // @@protoc_insertion_point(field_mutable:notepad.Version.id)
        return _s;
    }
    inline const std::string &Version::_internal_id() const
    {
        return _impl_.id_.Get();
    }
    inline void Version::_internal_set_id(const std::string &value)
    {

        _impl_.id_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_id()
    {

        return _impl_.id_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_id()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.id)
        return _impl_.id_.Release();
    }
    inline void Version::set_allocated_id(std::string *id)
    {
        if (id != nullptr)
        {
        }
        else
        {
        }
        _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault())
        {
            _impl_.id_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.id)
    }

    // int32 number = 2;
    inline void Version::clear_number()
    {
        _impl_.number_ = 0;
    }
    inline int32_t Version::_internal_number() const
    {
        return _impl_.number_;
    }
    inline int32_t Version::number() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.number)
        return _internal_number();
    }
    inline void Version::_internal_set_number(int32_t value)
    {

        _impl_.number_ = value;
    }
    inline void Version::set_number(int32_t value)
    {
        _internal_set_number(value);
        // @@protoc_insertion_point(field_set:notepad.Version.number)
    }

    // string created_time = 3;
    inline void Version::clear_created_time()
    {
        _impl_.created_time_.ClearToEmpty();
    }
    inline const std::string &Version::created_time() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.created_time)
        return _internal_created_time();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_created_time(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.created_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.created_time)
    }
    inline std::string *Version::mutable_created_time()
    {
        std::string *_s = _internal_mutable_created_time();
        // @@protoc_insertion_point(field_mutable:notepad.Version.created_time)
        return _s;
    }
    inline const std::string &Version::_internal_created_time() const
    {
        return _impl_.created_time_.Get();
    }
    inline void Version::_internal_set_created_time(const std::string &value)
    {

        _impl_.created_time_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_created_time()
    {

        return _impl_.created_time_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_created_time()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.created_time)
        return _impl_.created_time_.Release();
    }
    inline void Version::set_allocated_created_time(std::string *created_time)
    {
        if (created_time != nullptr)
        {
        }
        else
        {
        }
        _impl_.created_time_.SetAllocated(created_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.created_time_.IsDefault())
        {
            _impl_.created_time_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.created_time)
    }

    // string notepad_id = 4;
    inline void Version::clear_notepad_id()
    {
        _impl_.notepad_id_.ClearToEmpty();
    }
    inline const std::string &Version::notepad_id() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.notepad_id)
        return _internal_notepad_id();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_notepad_id(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.notepad_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.notepad_id)
    }
    inline std::string *Version::mutable_notepad_id()
    {
        std::string *_s = _internal_mutable_notepad_id();
        // @@protoc_insertion_point(field_mutable:notepad.Version.notepad_id)
        return _s;
    }
    inline const std::string &Version::_internal_notepad_id() const
    {
        return _impl_.notepad_id_.Get();
    }
    inline void Version::_internal_set_notepad_id(const std::string &value)
    {

        _impl_.notepad_id_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_notepad_id()
    {

        return _impl_.notepad_id_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_notepad_id()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.notepad_id)
        return _impl_.notepad_id_.Release();
    }
    inline void Version::set_allocated_notepad_id(std::string *notepad_id)
    {
        if (notepad_id != nullptr)
        {
        }
        else
        {
        }
        _impl_.notepad_id_.SetAllocated(notepad_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.notepad_id_.IsDefault())
        {
            _impl_.notepad_id_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.notepad_id)
    }

    // repeated .notepad.Change changes = 5;
    inline int Version::_internal_changes_size() const
    {
        return _impl_.changes_.size();
    }
    inline int Version::changes_size() const
    {
        return _internal_changes_size();
    }
    inline void Version::clear_changes()
    {
        _impl_.changes_.Clear();
    }
    inline ::notepad::Change *Version::mutable_changes(int index)
    {
        // @@protoc_insertion_point(field_mutable:notepad.Version.changes)
        return _impl_.changes_.Mutable(index);
    }
    inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Change> *
    Version::mutable_changes()
    {
        // @@protoc_insertion_point(field_mutable_list:notepad.Version.changes)
        return &_impl_.changes_;
    }
    inline const ::notepad::Change &Version::_internal_changes(int index) const
    {
        return _impl_.changes_.Get(index);
    }
    inline const ::notepad::Change &Version::changes(int index) const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.changes)
        return _internal_changes(index);
    }
    inline ::notepad::Change *Version::_internal_add_changes()
    {
        return _impl_.changes_.Add();
    }
    inline ::notepad::Change *Version::add_changes()
    {
        ::notepad::Change *_add = _internal_add_changes();
        // @@protoc_insertion_point(field_add:notepad.Version.changes)
        return _add;
    }
    inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Change> &
    Version::changes() const
    {
        // @@protoc_insertion_point(field_list:notepad.Version.changes)
        return _impl_.changes_;
    }

    // -------------------------------------------------------------------

    // Versions

    // repeated .notepad.Version versions = 1;
    inline int Versions::_internal_versions_size() const
    {
        return _impl_.versions_.size();
    }
    inline int Versions::versions_size() const
    {
        return _internal_versions_size();
    }
    inline void Versions::clear_versions()
    {
        _impl_.versions_.Clear();
    }
    inline ::notepad::Version *Versions::mutable_versions(int index)
    {
        // @@protoc_insertion_point(field_mutable:notepad.Versions.versions)
        return _impl_.versions_.Mutable(index);
    }
    inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Version> *
    Versions::mutable_versions()
    {
        // @@protoc_insertion_point(field_mutable_list:notepad.Versions.versions)
        return &_impl_.versions_;
    }
    inline const ::notepad::Version &Versions::_internal_versions(int index) const
    {
        return _impl_.versions_.Get(index);
    }
    inline const ::notepad::Version &Versions::versions(int index) const
    {
        // @@protoc_insertion_point(field_get:notepad.Versions.versions)
        return _internal_versions(index);
    }
    inline ::notepad::Version *Versions::_internal_add_versions()
    {
        return _impl_.versions_.Add();
    }
    inline ::notepad::Version *Versions::add_versions()
    {
        ::notepad::Version *_add = _internal_add_versions();
        // @@protoc_insertion_point(field_add:notepad.Versions.versions)
        return _add;
    }
    inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::Version> &
    Versions::versions() const
    {
        // @@protoc_insertion_point(field_list:notepad.Versions.versions)
        return _impl_.versions_;
    }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace notepad

PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::notepad::ChangeName> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::notepad::ChangeName>()
{
    return ::notepad::ChangeName_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto
