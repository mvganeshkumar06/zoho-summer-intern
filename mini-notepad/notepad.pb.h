// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notepad.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_notepad_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
    class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_notepad_2eproto
{
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_notepad_2eproto;
namespace notepad
{
    class Notepad;
    struct NotepadDefaultTypeInternal;
    extern NotepadDefaultTypeInternal _Notepad_default_instance_;
    class User;
    struct UserDefaultTypeInternal;
    extern UserDefaultTypeInternal _User_default_instance_;
    class Users;
    struct UsersDefaultTypeInternal;
    extern UsersDefaultTypeInternal _Users_default_instance_;
    class Version;
    struct VersionDefaultTypeInternal;
    extern VersionDefaultTypeInternal _Version_default_instance_;
} // namespace notepad
PROTOBUF_NAMESPACE_OPEN
template <>
::notepad::Notepad *Arena::CreateMaybeMessage<::notepad::Notepad>(Arena *);
template <>
::notepad::User *Arena::CreateMaybeMessage<::notepad::User>(Arena *);
template <>
::notepad::Users *Arena::CreateMaybeMessage<::notepad::Users>(Arena *);
template <>
::notepad::Version *Arena::CreateMaybeMessage<::notepad::Version>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace notepad
{

    // ===================================================================

    class User final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.User) */
    {
    public:
        inline User() : User(nullptr) {}
        ~User() override;
        explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        User(const User &from);
        User(User &&from) noexcept
            : User()
        {
            *this = ::std::move(from);
        }

        inline User &operator=(const User &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline User &operator=(User &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const User &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const User *internal_default_instance()
        {
            return reinterpret_cast<const User *>(
                &_User_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            0;

        friend void swap(User &a, User &b)
        {
            a.Swap(&b);
        }
        inline void Swap(User *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(User *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        User *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<User>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const User &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const User &from)
        {
            User::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(User *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.User";
        }

    protected:
        explicit User(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                      bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kNameFieldNumber = 1,
            kEmailFieldNumber = 2,
            kPasswordFieldNumber = 3,
            kLocationFieldNumber = 4,
        };
        // string name = 1;
        void clear_name();
        const std::string &name() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_name(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_name();
        PROTOBUF_NODISCARD std::string *release_name();
        void set_allocated_name(std::string *name);

    private:
        const std::string &_internal_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string &value);
        std::string *_internal_mutable_name();

    public:
        // string email = 2;
        void clear_email();
        const std::string &email() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_email(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_email();
        PROTOBUF_NODISCARD std::string *release_email();
        void set_allocated_email(std::string *email);

    private:
        const std::string &_internal_email() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string &value);
        std::string *_internal_mutable_email();

    public:
        // string password = 3;
        void clear_password();
        const std::string &password() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_password(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_password();
        PROTOBUF_NODISCARD std::string *release_password();
        void set_allocated_password(std::string *password);

    private:
        const std::string &_internal_password() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string &value);
        std::string *_internal_mutable_password();

    public:
        // string location = 4;
        void clear_location();
        const std::string &location() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_location(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_location();
        PROTOBUF_NODISCARD std::string *release_location();
        void set_allocated_location(std::string *location);

    private:
        const std::string &_internal_location() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string &value);
        std::string *_internal_mutable_location();

    public:
        // @@protoc_insertion_point(class_scope:notepad.User)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Users final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Users) */
    {
    public:
        inline Users() : Users(nullptr) {}
        ~Users() override;
        explicit PROTOBUF_CONSTEXPR Users(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Users(const Users &from);
        Users(Users &&from) noexcept
            : Users()
        {
            *this = ::std::move(from);
        }

        inline Users &operator=(const Users &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Users &operator=(Users &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Users &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Users *internal_default_instance()
        {
            return reinterpret_cast<const Users *>(
                &_Users_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            1;

        friend void swap(Users &a, Users &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Users *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Users *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Users *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Users>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Users &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Users &from)
        {
            Users::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Users *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Users";
        }

    protected:
        explicit Users(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                       bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kUsersFieldNumber = 1,
        };
        // repeated .notepad.User users = 1;
        int users_size() const;

    private:
        int _internal_users_size() const;

    public:
        void clear_users();
        ::notepad::User *mutable_users(int index);
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> *
        mutable_users();

    private:
        const ::notepad::User &_internal_users(int index) const;
        ::notepad::User *_internal_add_users();

    public:
        const ::notepad::User &users(int index) const;
        ::notepad::User *add_users();
        const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> &
        users() const;

        // @@protoc_insertion_point(class_scope:notepad.Users)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> users_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Notepad final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Notepad) */
    {
    public:
        inline Notepad() : Notepad(nullptr) {}
        ~Notepad() override;
        explicit PROTOBUF_CONSTEXPR Notepad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Notepad(const Notepad &from);
        Notepad(Notepad &&from) noexcept
            : Notepad()
        {
            *this = ::std::move(from);
        }

        inline Notepad &operator=(const Notepad &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Notepad &operator=(Notepad &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Notepad &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Notepad *internal_default_instance()
        {
            return reinterpret_cast<const Notepad *>(
                &_Notepad_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            2;

        friend void swap(Notepad &a, Notepad &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Notepad *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Notepad *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Notepad *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Notepad>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Notepad &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Notepad &from)
        {
            Notepad::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Notepad *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Notepad";
        }

    protected:
        explicit Notepad(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                         bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kIdFieldNumber = 1,
            kNameFieldNumber = 2,
            kUserIdFieldNumber = 3,
            kContentFieldNumber = 4,
        };
        // string id = 1;
        void clear_id();
        const std::string &id() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_id(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_id();
        PROTOBUF_NODISCARD std::string *release_id();
        void set_allocated_id(std::string *id);

    private:
        const std::string &_internal_id() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string &value);
        std::string *_internal_mutable_id();

    public:
        // string name = 2;
        void clear_name();
        const std::string &name() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_name(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_name();
        PROTOBUF_NODISCARD std::string *release_name();
        void set_allocated_name(std::string *name);

    private:
        const std::string &_internal_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string &value);
        std::string *_internal_mutable_name();

    public:
        // string userId = 3;
        void clear_userid();
        const std::string &userid() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_userid(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_userid();
        PROTOBUF_NODISCARD std::string *release_userid();
        void set_allocated_userid(std::string *userid);

    private:
        const std::string &_internal_userid() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string &value);
        std::string *_internal_mutable_userid();

    public:
        // string content = 4;
        void clear_content();
        const std::string &content() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_content(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_content();
        PROTOBUF_NODISCARD std::string *release_content();
        void set_allocated_content(std::string *content);

    private:
        const std::string &_internal_content() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string &value);
        std::string *_internal_mutable_content();

    public:
        // @@protoc_insertion_point(class_scope:notepad.Notepad)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // -------------------------------------------------------------------

    class Version final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.Version) */
    {
    public:
        inline Version() : Version(nullptr) {}
        ~Version() override;
        explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        Version(const Version &from);
        Version(Version &&from) noexcept
            : Version()
        {
            *this = ::std::move(from);
        }

        inline Version &operator=(const Version &from)
        {
            CopyFrom(from);
            return *this;
        }
        inline Version &operator=(Version &&from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const Version &default_instance()
        {
            return *internal_default_instance();
        }
        static inline const Version *internal_default_instance()
        {
            return reinterpret_cast<const Version *>(
                &_Version_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            3;

        friend void swap(Version &a, Version &b)
        {
            a.Swap(&b);
        }
        inline void Swap(Version *other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(Version *other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        Version *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
            return CreateMaybeMessage<Version>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const Version &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const Version &from)
        {
            Version::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(Version *other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "notepad.Version";
        }

    protected:
        explicit Version(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                         bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kNumberFieldNumber = 1,
            kCreatedTimeFieldNumber = 2,
            kNotepadIdFieldNumber = 3,
            kContentFieldNumber = 4,
        };
        // string number = 1;
        void clear_number();
        const std::string &number() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_number(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_number();
        PROTOBUF_NODISCARD std::string *release_number();
        void set_allocated_number(std::string *number);

    private:
        const std::string &_internal_number() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_number(const std::string &value);
        std::string *_internal_mutable_number();

    public:
        // string createdTime = 2;
        void clear_createdtime();
        const std::string &createdtime() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_createdtime(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_createdtime();
        PROTOBUF_NODISCARD std::string *release_createdtime();
        void set_allocated_createdtime(std::string *createdtime);

    private:
        const std::string &_internal_createdtime() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_createdtime(const std::string &value);
        std::string *_internal_mutable_createdtime();

    public:
        // string notepadId = 3;
        void clear_notepadid();
        const std::string &notepadid() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_notepadid(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_notepadid();
        PROTOBUF_NODISCARD std::string *release_notepadid();
        void set_allocated_notepadid(std::string *notepadid);

    private:
        const std::string &_internal_notepadid() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_notepadid(const std::string &value);
        std::string *_internal_mutable_notepadid();

    public:
        // string content = 4;
        void clear_content();
        const std::string &content() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_content(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_content();
        PROTOBUF_NODISCARD std::string *release_content();
        void set_allocated_content(std::string *content);

    private:
        const std::string &_internal_content() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string &value);
        std::string *_internal_mutable_content();

    public:
        // @@protoc_insertion_point(class_scope:notepad.Version)
    private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr createdtime_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notepadid_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_notepad_2eproto;
    };
    // ===================================================================

    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
    // User

    // string name = 1;
    inline void User::clear_name()
    {
        _impl_.name_.ClearToEmpty();
    }
    inline const std::string &User::name() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.name)
        return _internal_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_name(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.name)
    }
    inline std::string *User::mutable_name()
    {
        std::string *_s = _internal_mutable_name();
        // @@protoc_insertion_point(field_mutable:notepad.User.name)
        return _s;
    }
    inline const std::string &User::_internal_name() const
    {
        return _impl_.name_.Get();
    }
    inline void User::_internal_set_name(const std::string &value)
    {

        _impl_.name_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_name()
    {

        return _impl_.name_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_name()
    {
        // @@protoc_insertion_point(field_release:notepad.User.name)
        return _impl_.name_.Release();
    }
    inline void User::set_allocated_name(std::string *name)
    {
        if (name != nullptr)
        {
        }
        else
        {
        }
        _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault())
        {
            _impl_.name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.name)
    }

    // string email = 2;
    inline void User::clear_email()
    {
        _impl_.email_.ClearToEmpty();
    }
    inline const std::string &User::email() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.email)
        return _internal_email();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_email(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.email)
    }
    inline std::string *User::mutable_email()
    {
        std::string *_s = _internal_mutable_email();
        // @@protoc_insertion_point(field_mutable:notepad.User.email)
        return _s;
    }
    inline const std::string &User::_internal_email() const
    {
        return _impl_.email_.Get();
    }
    inline void User::_internal_set_email(const std::string &value)
    {

        _impl_.email_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_email()
    {

        return _impl_.email_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_email()
    {
        // @@protoc_insertion_point(field_release:notepad.User.email)
        return _impl_.email_.Release();
    }
    inline void User::set_allocated_email(std::string *email)
    {
        if (email != nullptr)
        {
        }
        else
        {
        }
        _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault())
        {
            _impl_.email_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.email)
    }

    // string password = 3;
    inline void User::clear_password()
    {
        _impl_.password_.ClearToEmpty();
    }
    inline const std::string &User::password() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.password)
        return _internal_password();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_password(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.password)
    }
    inline std::string *User::mutable_password()
    {
        std::string *_s = _internal_mutable_password();
        // @@protoc_insertion_point(field_mutable:notepad.User.password)
        return _s;
    }
    inline const std::string &User::_internal_password() const
    {
        return _impl_.password_.Get();
    }
    inline void User::_internal_set_password(const std::string &value)
    {

        _impl_.password_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_password()
    {

        return _impl_.password_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_password()
    {
        // @@protoc_insertion_point(field_release:notepad.User.password)
        return _impl_.password_.Release();
    }
    inline void User::set_allocated_password(std::string *password)
    {
        if (password != nullptr)
        {
        }
        else
        {
        }
        _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault())
        {
            _impl_.password_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.password)
    }

    // string location = 4;
    inline void User::clear_location()
    {
        _impl_.location_.ClearToEmpty();
    }
    inline const std::string &User::location() const
    {
        // @@protoc_insertion_point(field_get:notepad.User.location)
        return _internal_location();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void User::set_location(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.User.location)
    }
    inline std::string *User::mutable_location()
    {
        std::string *_s = _internal_mutable_location();
        // @@protoc_insertion_point(field_mutable:notepad.User.location)
        return _s;
    }
    inline const std::string &User::_internal_location() const
    {
        return _impl_.location_.Get();
    }
    inline void User::_internal_set_location(const std::string &value)
    {

        _impl_.location_.Set(value, GetArenaForAllocation());
    }
    inline std::string *User::_internal_mutable_location()
    {

        return _impl_.location_.Mutable(GetArenaForAllocation());
    }
    inline std::string *User::release_location()
    {
        // @@protoc_insertion_point(field_release:notepad.User.location)
        return _impl_.location_.Release();
    }
    inline void User::set_allocated_location(std::string *location)
    {
        if (location != nullptr)
        {
        }
        else
        {
        }
        _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault())
        {
            _impl_.location_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.User.location)
    }

    // -------------------------------------------------------------------

    // Users

    // repeated .notepad.User users = 1;
    inline int Users::_internal_users_size() const
    {
        return _impl_.users_.size();
    }
    inline int Users::users_size() const
    {
        return _internal_users_size();
    }
    inline void Users::clear_users()
    {
        _impl_.users_.Clear();
    }
    inline ::notepad::User *Users::mutable_users(int index)
    {
        // @@protoc_insertion_point(field_mutable:notepad.Users.users)
        return _impl_.users_.Mutable(index);
    }
    inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> *
    Users::mutable_users()
    {
        // @@protoc_insertion_point(field_mutable_list:notepad.Users.users)
        return &_impl_.users_;
    }
    inline const ::notepad::User &Users::_internal_users(int index) const
    {
        return _impl_.users_.Get(index);
    }
    inline const ::notepad::User &Users::users(int index) const
    {
        // @@protoc_insertion_point(field_get:notepad.Users.users)
        return _internal_users(index);
    }
    inline ::notepad::User *Users::_internal_add_users()
    {
        return _impl_.users_.Add();
    }
    inline ::notepad::User *Users::add_users()
    {
        ::notepad::User *_add = _internal_add_users();
        // @@protoc_insertion_point(field_add:notepad.Users.users)
        return _add;
    }
    inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::notepad::User> &
    Users::users() const
    {
        // @@protoc_insertion_point(field_list:notepad.Users.users)
        return _impl_.users_;
    }

    // -------------------------------------------------------------------

    // Notepad

    // string id = 1;
    inline void Notepad::clear_id()
    {
        _impl_.id_.ClearToEmpty();
    }
    inline const std::string &Notepad::id() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.id)
        return _internal_id();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_id(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.id)
    }
    inline std::string *Notepad::mutable_id()
    {
        std::string *_s = _internal_mutable_id();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.id)
        return _s;
    }
    inline const std::string &Notepad::_internal_id() const
    {
        return _impl_.id_.Get();
    }
    inline void Notepad::_internal_set_id(const std::string &value)
    {

        _impl_.id_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_id()
    {

        return _impl_.id_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_id()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.id)
        return _impl_.id_.Release();
    }
    inline void Notepad::set_allocated_id(std::string *id)
    {
        if (id != nullptr)
        {
        }
        else
        {
        }
        _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault())
        {
            _impl_.id_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.id)
    }

    // string name = 2;
    inline void Notepad::clear_name()
    {
        _impl_.name_.ClearToEmpty();
    }
    inline const std::string &Notepad::name() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.name)
        return _internal_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_name(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.name)
    }
    inline std::string *Notepad::mutable_name()
    {
        std::string *_s = _internal_mutable_name();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.name)
        return _s;
    }
    inline const std::string &Notepad::_internal_name() const
    {
        return _impl_.name_.Get();
    }
    inline void Notepad::_internal_set_name(const std::string &value)
    {

        _impl_.name_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_name()
    {

        return _impl_.name_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_name()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.name)
        return _impl_.name_.Release();
    }
    inline void Notepad::set_allocated_name(std::string *name)
    {
        if (name != nullptr)
        {
        }
        else
        {
        }
        _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault())
        {
            _impl_.name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.name)
    }

    // string userId = 3;
    inline void Notepad::clear_userid()
    {
        _impl_.userid_.ClearToEmpty();
    }
    inline const std::string &Notepad::userid() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.userId)
        return _internal_userid();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_userid(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.userId)
    }
    inline std::string *Notepad::mutable_userid()
    {
        std::string *_s = _internal_mutable_userid();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.userId)
        return _s;
    }
    inline const std::string &Notepad::_internal_userid() const
    {
        return _impl_.userid_.Get();
    }
    inline void Notepad::_internal_set_userid(const std::string &value)
    {

        _impl_.userid_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_userid()
    {

        return _impl_.userid_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_userid()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.userId)
        return _impl_.userid_.Release();
    }
    inline void Notepad::set_allocated_userid(std::string *userid)
    {
        if (userid != nullptr)
        {
        }
        else
        {
        }
        _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault())
        {
            _impl_.userid_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.userId)
    }

    // string content = 4;
    inline void Notepad::clear_content()
    {
        _impl_.content_.ClearToEmpty();
    }
    inline const std::string &Notepad::content() const
    {
        // @@protoc_insertion_point(field_get:notepad.Notepad.content)
        return _internal_content();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Notepad::set_content(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Notepad.content)
    }
    inline std::string *Notepad::mutable_content()
    {
        std::string *_s = _internal_mutable_content();
        // @@protoc_insertion_point(field_mutable:notepad.Notepad.content)
        return _s;
    }
    inline const std::string &Notepad::_internal_content() const
    {
        return _impl_.content_.Get();
    }
    inline void Notepad::_internal_set_content(const std::string &value)
    {

        _impl_.content_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Notepad::_internal_mutable_content()
    {

        return _impl_.content_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Notepad::release_content()
    {
        // @@protoc_insertion_point(field_release:notepad.Notepad.content)
        return _impl_.content_.Release();
    }
    inline void Notepad::set_allocated_content(std::string *content)
    {
        if (content != nullptr)
        {
        }
        else
        {
        }
        _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault())
        {
            _impl_.content_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Notepad.content)
    }

    // -------------------------------------------------------------------

    // Version

    // string number = 1;
    inline void Version::clear_number()
    {
        _impl_.number_.ClearToEmpty();
    }
    inline const std::string &Version::number() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.number)
        return _internal_number();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_number(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.number)
    }
    inline std::string *Version::mutable_number()
    {
        std::string *_s = _internal_mutable_number();
        // @@protoc_insertion_point(field_mutable:notepad.Version.number)
        return _s;
    }
    inline const std::string &Version::_internal_number() const
    {
        return _impl_.number_.Get();
    }
    inline void Version::_internal_set_number(const std::string &value)
    {

        _impl_.number_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_number()
    {

        return _impl_.number_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_number()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.number)
        return _impl_.number_.Release();
    }
    inline void Version::set_allocated_number(std::string *number)
    {
        if (number != nullptr)
        {
        }
        else
        {
        }
        _impl_.number_.SetAllocated(number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.number_.IsDefault())
        {
            _impl_.number_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.number)
    }

    // string createdTime = 2;
    inline void Version::clear_createdtime()
    {
        _impl_.createdtime_.ClearToEmpty();
    }
    inline const std::string &Version::createdtime() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.createdTime)
        return _internal_createdtime();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_createdtime(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.createdtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.createdTime)
    }
    inline std::string *Version::mutable_createdtime()
    {
        std::string *_s = _internal_mutable_createdtime();
        // @@protoc_insertion_point(field_mutable:notepad.Version.createdTime)
        return _s;
    }
    inline const std::string &Version::_internal_createdtime() const
    {
        return _impl_.createdtime_.Get();
    }
    inline void Version::_internal_set_createdtime(const std::string &value)
    {

        _impl_.createdtime_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_createdtime()
    {

        return _impl_.createdtime_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_createdtime()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.createdTime)
        return _impl_.createdtime_.Release();
    }
    inline void Version::set_allocated_createdtime(std::string *createdtime)
    {
        if (createdtime != nullptr)
        {
        }
        else
        {
        }
        _impl_.createdtime_.SetAllocated(createdtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.createdtime_.IsDefault())
        {
            _impl_.createdtime_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.createdTime)
    }

    // string notepadId = 3;
    inline void Version::clear_notepadid()
    {
        _impl_.notepadid_.ClearToEmpty();
    }
    inline const std::string &Version::notepadid() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.notepadId)
        return _internal_notepadid();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_notepadid(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.notepadid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.notepadId)
    }
    inline std::string *Version::mutable_notepadid()
    {
        std::string *_s = _internal_mutable_notepadid();
        // @@protoc_insertion_point(field_mutable:notepad.Version.notepadId)
        return _s;
    }
    inline const std::string &Version::_internal_notepadid() const
    {
        return _impl_.notepadid_.Get();
    }
    inline void Version::_internal_set_notepadid(const std::string &value)
    {

        _impl_.notepadid_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_notepadid()
    {

        return _impl_.notepadid_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_notepadid()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.notepadId)
        return _impl_.notepadid_.Release();
    }
    inline void Version::set_allocated_notepadid(std::string *notepadid)
    {
        if (notepadid != nullptr)
        {
        }
        else
        {
        }
        _impl_.notepadid_.SetAllocated(notepadid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.notepadid_.IsDefault())
        {
            _impl_.notepadid_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.notepadId)
    }

    // string content = 4;
    inline void Version::clear_content()
    {
        _impl_.content_.ClearToEmpty();
    }
    inline const std::string &Version::content() const
    {
        // @@protoc_insertion_point(field_get:notepad.Version.content)
        return _internal_content();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void Version::set_content(ArgT0 &&arg0, ArgT... args)
    {

        _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:notepad.Version.content)
    }
    inline std::string *Version::mutable_content()
    {
        std::string *_s = _internal_mutable_content();
        // @@protoc_insertion_point(field_mutable:notepad.Version.content)
        return _s;
    }
    inline const std::string &Version::_internal_content() const
    {
        return _impl_.content_.Get();
    }
    inline void Version::_internal_set_content(const std::string &value)
    {

        _impl_.content_.Set(value, GetArenaForAllocation());
    }
    inline std::string *Version::_internal_mutable_content()
    {

        return _impl_.content_.Mutable(GetArenaForAllocation());
    }
    inline std::string *Version::release_content()
    {
        // @@protoc_insertion_point(field_release:notepad.Version.content)
        return _impl_.content_.Release();
    }
    inline void Version::set_allocated_content(std::string *content)
    {
        if (content != nullptr)
        {
        }
        else
        {
        }
        _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault())
        {
            _impl_.content_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
       // @@protoc_insertion_point(field_set_allocated:notepad.Version.content)
    }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace notepad

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto
